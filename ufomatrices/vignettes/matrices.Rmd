---
title: "Using UFO Matrices"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using UFO Matrices}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Package *ufomatrices* is an example implementation of R matrices using User Fault Objects (UFOs) from the *ufos* package. UFOs spoof vectors by constructing SEXP structures that look exactly like ordinary R vectors to the R interpreter, but trigger the UFO framework when their memory is accessed. The framework then loads appropriate data from an arbitrary *source* (eg. a binary file on a harddrive) into memory and gives access to it to the R interpreter. The data will also be "forgotten" and the memory freed if a vector threatens to overrun memory.

Let's examine a short example to see all this in action. First, let's load the package.

```{r setup}
library(ufomatrices)
```

Note, that the package loads *ufos* as a dependency.

The *ufomatrices* package provides constructors for various types of matrices:

* `ufo_matrix_integer_bin (path)`
* `ufo_matrix_numeric_bin (path)`
* `ufo_matrix_logical_bin (path)`
* `ufo_matrix_complex_bin (path)`
* `ufo_matrix_raw_bin (path)`

Each of these functions requires a path to a binary file that will provide the data that populates the matrix. Internally, an R matrix is really just an R vector with the additional `dims` attribute specifying the dimensions of the matrix, and a `class` attribute of `"matrix"`. To fit this structure, the binary file that we supply provides the dimensions as well as the contents of the matrix.

Our example binary file at path `example_int_256x256.bin` contains 2 64-bit and 2^16 32-bit consecutive little-endian-encoded values. The first two values specify the matrix's dimensions and are the size of type `size_t`, and the remainder constitute the data. In effect the file looks like this:

```
00 10 00 00  00 00 00 00  00 10 00 00  00 00 00 00
00 00 00 00  01 00 00 00  02 00 00 00  03 00 00 00  
04 00 00 00  05 00 00 00  06 00 00 00  07 00 00 00  
08 00 00 00  09 00 00 00  0A 00 00 00  0B 00 00 00  
0C 00 00 00  0D 00 00 00  0E 00 00 00  0F 00 00 00  
...
```

We can use this file as a source to populate an integer vector containing the values `0:65535`. The dimensions will specify that the matrix has 256 rows and 256 columns.

Let's actaully create the matrix.

```{r ufovectors-create-int-vector}
m <- ufo_matrix_integer_bin("example_int_256x256.bin")
```

When we execute this function the R interpreter asks the UF engine to allocate some memory using a custom allocator that will be used to store a vector. However, instead of allocating any real memory for this vector, UF engine allocates some virtual memory for it, thus rendering it a UFO. Whenever that memory is accesed, the operating system passes on a request to the UF system to allocate and populate some real memory. At this time, since we did not ask for any data from `iv`, the vector does not load any memory. We only read three things from the disk too: the dimensions of the vector from the head of the file, and the length of the file, by seeking its end.

Before we do anything, let's turn on debug mode to see what happens under the hood.

```{r ufovectors-turn-on-debug}
ufo_matrix_set_debug_mode(T)
```

Now, let's try accessing an element of an array.

```{r ufovectos-poke-int-vector}
iv[4]
```

Once we access an element, the UF engine prepares a region of actual memory and asks its source to populate it. Since the source is a binary file, a chunk of the file is read into memory. We see exactly which chunk of the file is loaded into memory in the debug message. The size of the chunk depends on the UF engine, but it's at least a page fo memory.

If we access some more elements again, this data is actually in memory and no more loading takes place.

```{r ufovectos-poke-int-vector-again}
iv[4]
iv[5]
```

If we access elements outside of the loaded chunk, the source will be asked to provide another chunk.

```{r ufovectos-poke-int-vector-load-another-chunk}`
iv[10000]
```

We see again through the debug message that another chunk was loaded into memory.


