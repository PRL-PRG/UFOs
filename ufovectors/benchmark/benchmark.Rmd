---
title: "Benchmarks"
author: "K. Siek"
date: "March 6, 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```R
devtools::install_github("olafmersmann/microbenchmarkCore")
devtools::install_github("olafmersmann/microbenchmark")
```

```{r}
#library(ufoseq)
library(ufovectors)
library(ufoaltrep)
library(microbenchmark)
library(ggplot2)
```

```R
setwd("~/Workspace/ufo_workspace/UFOs/ufovectors/benchmark")
ufo_set_debug_mode(F)
options(scipen=999) # effectively turns off scientific notation
```

## Generating files

```{r generate}
generate_binary_file <- function(path, range, repeats) {
  sum <- 0
  minimum <- integer(0)
  maximum <- integer(0)
  size <- length(range) * repeats
  f <- file(path, "wb")
  for (i in 0:repeats) {
    writeBin(range, f)
    sum <- sum + sum(range, na.rm = TRUE)
    minimum <- min(minimum, range, na.rm = TRUE)
    maximum <- max(maximum, range, na.rm = TRUE)
  }
  close(f)
  list(path=path, sum=sum, size=size, min=minimum, max=maximum)
}

stats <- list(
  stats_32mln_1s = generate_binary_file("32mln_1s.bin", as.integer(rep(1, 1000000)), 32), #126MB
  stats_32mln_seq_ints = generate_binary_file("32mln_seq_ints.bin", 1:1000000, 32),
  stats_32mln_rand_ints = generate_binary_file("32mln_rand_ints.bin", sample(1000000, replace=T), 32)
)

print(stats)
```

## File-backed matrices

Two nigh-identical implementations of file-backed vectors. One done with UFOs, one done with vectors.

### Sum: 32 million 1s

```{r fb-sum32mln1, cache=T}
min_load_count = 1024 * 1024 / 4

result <- microbenchmark(
  "UFO" = { 
    sum(ufo_integer_bin(stats$stats_32mln_1s$path, min_load_count))
  },
  "ALTREP" = {
    sum(altrep_ufo_integer_bin(stats$stats_32mln_1s$path))
  },
  check = function(values) {
    # turns out 32 mln 1s is 32mln
    all(sapply(values, function(result) result == stats$stats_32mln_1s$sum))
  },
  times = 50L
)

autoplot(result)
```

### Sum: 32 million random integers

```{r fb-sum32mlnrand, cache=T}
min_load_count = 1024 * 1024 / 4
actually_check = T

result <- microbenchmark(
  "UFO" = { 
    sum(ufo_integer_bin(stats$stats_32mln_rand_ints$path, min_load_count))
  },
  "ALTREP" = {
    sum(altrep_ufo_integer_bin(stats$stats_32mln_rand_ints$path))
  },
  check = function(values) {
    if (actually_check) {
      all(sapply(values, function(result) result == stats$stats_32mln_rand_ints$sum))
    } else
      TRUE
  },
  times = 50L
)

autoplot(result)
```

### For loop: 32 million random integers

```{r fb-for32mlnrand, cache=T}
min_load_count = 1024 * 1024 / 4
some_function <- function(x) x

result <- microbenchmark(
  "UFO" = {
    for (e in ufo_integer_bin(stats$stats_32mln_rand_ints$path, min_load_count)) some_function(e)
  },
  "ALTREP" = {
    for (e in altrep_ufo_integer_bin(stats$stats_32mln_rand_ints$path)) some_function(e)
  },
  times = 1L
)

autoplot(result)
```

ALTREP is really slow because:
- it has to do dispatch on each element
- it has to read from disk on each element

TODO: add an ALTREP implementation that buffers elements.

## Sequences

Here I'm comparing 

- our implementation of sequences, vs.
- `seq.int` which just returns an ordinary R vector, vs. 
- a compact vector (result of `n:m`), which, *I believe*, is implemented with ALTREP

## Sum: 32 mln int sequence

```{r seq-sum32mln, cache=T}
size = 32000000

result <- microbenchmark(
  "ufoseq" = {
    sum(ufo_seq(1, size, 1))
  },
  "seq.int" = {
    sum(seq.int(1, size, 1))
  },
  "compact vector" = {
    sum(1:size)
  },
  times = 50L
)

autoplot(result)
```

They implement their own sum, which doesn't go through all the elements, instead it just calculates the sum from the boundaries of the sequence:

```C
(size / 2.0) * (n1 + n1 + inc * (size - 1))
```



## For loop: 32 mln int sequence

```{r fseq-for32mln, cache=T}
size = 32000000
some_function <- function(x) x

result <- microbenchmark(
  "ufoseq" = {
    for (e in ufo_seq(1, size, 1)) some_function(e)
  },
  "seq.int" = {
    for (e in seq.int(1, size, 1)) some_function(e)
  },
  "compact vector" = {
    for (e in 1:size) some_function(e)
  },
  times = 10L
)

autoplot(result)
```